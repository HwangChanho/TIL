2024.12.16

## 점진적 가비지 컬렉션(Incremental Garbage Collection)

언리얼 엔진의 **점진적 가비지 컬렉션(Incremental Garbage Collection)**은 게임 실행 중에 메모리 관리를 효율적으로 처리하기 위한 방식으로, 프레임 단위로 가비지 컬렉션 작업을 나누어 수행합니다. 이 방식은 **지연 시간 최소화**와 **프레임률 유지**를 목표로 설계되었습니다.

---

### **1. 점진적 가비지 컬렉션이란?**

- **점진적(Incremental)**: 전체 가비지 컬렉션을 한 번에 처리하지 않고, 여러 프레임에 걸쳐 나누어 수행.
- 실시간 애플리케이션(특히 게임)에서 **성능 저하(스파이크)**를 방지하기 위해 사용.

언리얼 엔진의 기본 가비지 컬렉션 방식은 점진적이며, 이를 통해 게임 플레이 중 프레임률을 안정적으로 유지할 수 있습니다.

---

### **2. 작동 원리**

### **가비지 컬렉션의 단계**

가비지 컬렉션은 크게 **마킹(Marking)**, **스위핑(Sweeping)**, **압축(Compacting)**의 3단계로 나뉩니다.

점진적 가비지 컬렉션은 이 과정을 나누어 각 프레임에서 조금씩 처리합니다.

1. **마킹(Marking)**
    - UObject의 **참조 그래프(Reference Graph)**를 분석하여 사용 중인 객체를 식별.
    - 루트 객체(예: 월드 객체, 플레이어 객체)부터 시작해 연결된 객체를 마킹.
2. **스위핑(Sweeping)**
    - 마킹되지 않은 객체(더 이상 참조되지 않는 객체)를 제거.
3. **압축(선택적)**
    - 필요에 따라 메모리를 재배치하여 조각화를 줄이고 효율성을 높임.

### **점진적 처리**

- 각 단계의 작업을 작은 작업 단위로 나눠 프레임마다 처리.
- 예: 첫 번째 프레임에서는 일부 객체를 마킹하고, 다음 프레임에서는 나머지 객체를 처리.

---

### **3. 장점**

1. **지연 시간 최소화**
    - 한 번에 많은 작업을 수행하지 않아 **프레임 드랍**을 방지.
    - 게임이 부드럽게 실행되도록 보장.
2. **실시간 응답성**
    - 가비지 컬렉션이 게임플레이에 방해되지 않도록 조정 가능.
3. **효율적 메모리 관리**
    - 사용하지 않는 UObject를 자동으로 제거해 메모리 누수를 방지.

---

### **4. 설정 및 제어**

### **GC 관련 설정**

언리얼 엔진에서 가비지 컬렉션 동작은 `DefaultEngine.ini` 파일이나 코드로 조정할 수 있습니다.

- **타임 슬라이스(Time Slice)**
    - 각 프레임에서 가비지 컬렉션에 허용하는 시간.
    - 예: `gc.TimeBetweenPurgingPendingKillObjects` 값을 조정하여 GC 간격을 설정.
- **Threshold 설정**
    - 가비지 컬렉션이 실행되기 전에 UObject 개수 임계값을 설정.
    - 예: `gc.MinGCClusterSize`, `gc.MaxObjectsNotConsideredByGC`.

### **명시적 호출**

가비지 컬렉션은 필요에 따라 명시적으로 호출할 수도 있습니다.

- 코드에서 호출:
    
    ```cpp
    GetWorld()->ForceGarbageCollection(true);
    ```
    

---

### **5. 주의점**

1. **GC 스파이크**
    - 점진적으로 처리하지 못한 경우 큰 객체 풀이나 메모리 누적으로 인해 한 번에 많은 작업이 수행될 수 있음.
    - 해결책: `gc.MaxObjectsNotConsideredByGC` 값을 적절히 조정.
2. **레퍼런스 관리**
    - UObject가 참조 해제되지 않으면 가비지 컬렉션이 작동하지 않음(메모리 누수 발생).
    - `TWeakObjectPtr`나 `Soft References` 사용 권장.
3. **핫루프 처리**
    - 객체가 지속적으로 생성되고 제거되는 핫루프에서는 가비지 컬렉션 빈도를 높이는 것이 필요.

---

### **6. 실전 팁**

- **프로파일링**: Unreal Insights를 사용해 가비지 컬렉션의 성능 영향을 확인.
- **작업 분할**: 가비지 컬렉션 시간이 길어질 경우 타임 슬라이스를 세밀하게 조정.
- **메모리 최적화**: 필요 없는 객체를 즉시 제거하거나 풀링(pooling) 전략을 활용.

---

### **결론**

점진적 가비지 컬렉션은 언리얼 엔진의 실시간 게임 환경에서 성능을 유지하면서 메모리를 안정적으로 관리할 수 있게 해줍니다. 설정과 튜닝을 통해 GC 스파이크를 최소화하고, 객체 참조 관리를 철저히 하면 최상의 결과를 얻을 수 있습니다.

## 풀링(Pooling)

**풀링(Pooling) 전략**은 게임 개발에서 자주 생성하고 파괴되는 객체들을 미리 생성하여 **재사용**하는 방식으로, 성능 최적화와 메모리 관리를 위해 사용됩니다. 특히, 객체를 빈번히 생성하거나 소멸시키는 작업이 많은 경우, 풀링을 통해 CPU와 메모리 리소스를 절약할 수 있습니다.

---

### **1. 풀링의 기본 개념**

- **풀(Pool)**: 특정 객체의 인스턴스를 미리 생성해두는 저장 공간.
- 객체를 필요할 때 생성하는 대신, 미리 생성된 객체를 꺼내 사용하고, 다시 반환해 재사용.
- 주요 목표: **비용이 큰 메모리 할당과 해제를 최소화**하고, 성능을 개선.

---

### **2. 풀링이 필요한 이유**

1. **객체 생성 및 파괴의 비용 절감**
    - 객체 생성(할당)과 삭제(해제)는 비용이 큰 연산으로, 성능 저하의 원인이 될 수 있음.
    - 특히, 짧은 주기로 반복적으로 생성/삭제가 발생하면 **GC(Garbage Collection)**의 부담을 증가시켜 프레임 드랍을 유발.
2. **실시간 성능 유지**
    - 실시간 환경(게임, 애니메이션 등)에서 FPS(Frames Per Second)를 안정적으로 유지.
3. **효율적인 메모리 관리**
    - 객체를 재활용해 메모리 조각화를 줄이고 효율성을 향상.
4. **게임 개발 사례**
    - 총알, 적 캐릭터, 파티클 이펙트 등 자주 생성/삭제되는 오브젝트에서 필수적으로 사용.

---

### **3. 풀링의 구조**

1. **객체 풀 생성**
    - 객체를 일정 개수 미리 생성하여 **대기 상태**로 저장.
2. **객체 요청(Get)**
    - 필요한 객체를 풀에서 가져와 사용.
    - 풀에 남아 있는 객체가 없으면 새 객체를 생성하거나 기존 풀을 확장.
3. **객체 반환(Return)**
    - 사용이 끝난 객체를 초기화한 뒤 다시 풀에 반환.
    - 반환된 객체는 재사용 가능하도록 상태를 리셋.

---

### **4. 언리얼 엔진에서 풀링 구현**

언리얼 엔진에서는 객체 풀링을 커스터마이징하여 구현하거나, 이미 제공된 시스템을 활용할 수 있습니다.

### **A. 커스텀 풀링 시스템**

풀링 전략은 객체 유형에 따라 다르지만, 기본 구조는 다음과 같습니다:

1. **UObject 풀링**
    - UObject 기반 클래스를 풀링:
        
        ```cpp
        class UObjectPool
        {
        private:
            TArray<UObject*> Pool;
        
        public:
            UObject* GetObject()
            {
                if (Pool.Num() > 0)
                {
                    UObject* PooledObject = Pool.Pop();
                    return PooledObject;
                }
                return NewObject<UObject>();
            }
        
            void ReturnObject(UObject* Object)
            {
                Pool.Add(Object);
            }
        };
        ```
        
2. **AActor 풀링**
    - AActor는 월드에 스폰되기 때문에 특별한 풀링이 필요.
    - `SpawnActor`와 `SetActorHiddenInGame`을 활용:
        
        ```cpp
        AActor* APooledActor::GetPooledActor(UWorld* World, TSubclassOf<AActor> ActorClass)
        {
            if (InactiveActors.Num() > 0)
            {
                AActor* Actor = InactiveActors.Pop();
                Actor->SetActorHiddenInGame(false);
                return Actor;
            }
            return World->SpawnActor<AActor>(ActorClass);
        }
        
        void APooledActor::ReturnPooledActor(AActor* Actor)
        {
            Actor->SetActorHiddenInGame(true);
            InactiveActors.Add(Actor);
        }
        ```
        

### **B. Unreal Engine 시스템 활용**

- **Object Pool 플러그인**: 언리얼 엔진 마켓플레이스에서 제공되는 풀링 시스템 사용.
- **파티클 풀링**: 언리얼 엔진의 `Niagara`에서 일부 지원.
    - `NiagaraComponent`를 숨기고 재활용 가능.

---

### **5. 장점**

1. **성능 향상**
    - 메모리 할당 및 해제 빈도를 줄여 CPU와 GC 부담 감소.
2. **일관된 프레임 타임**
    - 프레임 드랍과 같은 성능 스파이크 방지.
3. **개발 효율성**
    - 객체 재사용으로 메모리 관리 간소화.

---

### **6. 단점 및 주의점**

1. **초기 메모리 사용량 증가**
    - 객체를 미리 생성하므로 초기 메모리 소비가 많아질 수 있음.
2. **풀 크기 관리 필요**
    - 너무 작은 풀은 풀 부족 문제를, 너무 큰 풀은 메모리 낭비를 초래.
3. **상태 초기화 문제**
    - 반환된 객체가 이전 상태를 유지할 수 있으므로 재사용 전 초기화가 중요.

---

### **7. 사례**

1. **총알 풀링**
    - FPS 게임에서 매 프레임마다 총알을 생성/파괴하면 성능 저하.
    - 총알 객체를 미리 생성하여 발사 시 재사용:
        
        ```cpp
        PooledBullet->SetActorLocation(SpawnLocation);
        PooledBullet->SetActorRotation(SpawnRotation);
        ```
        
2. **적 캐릭터 풀링**
    - 웨이브 기반 적 생성 시스템에서 적 캐릭터를 재활용.
3. **파티클 이펙트 풀링**
    - 폭발, 불꽃 등 자주 사용되는 이펙트를 숨겨두고 필요할 때 활성화.

---

### **결론**

풀링 전략은 반복적인 객체 생성/삭제가 많은 게임에서 성능 최적화의 필수 요소입니다. 언리얼 엔진에서는 풀링 시스템을 커스텀 구현하거나 기존 플러그인을 활용할 수 있으며, 초기 메모리 관리와 상태 초기화에 주의하면 큰 효과를 얻을 수 있습니다.